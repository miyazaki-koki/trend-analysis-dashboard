---
name: learn-break
description: あえて壊して学ぶ。コードの一部を変更したらどうなるかシナリオを提案し、試行錯誤でデバッグ能力を鍛える。実装完了後、深い理解を得たい時に使用。
allowed-tools: Bash, Read, Glob, Grep
argument-hint: [--selection | --file <path>] [focus: error|edge|performance]
---

# Learn Break - 壊して学ぶ

「あえて壊してみる」ことで、コードの動作原理を深く理解するスキルです。
Anthropicの研究によると、デバッグ能力はAI依存で最も差が出る能力です。

## 目的

> 一部の数値を書き換えたり、条件を外したりして、どう挙動が変わるか、どんなエラーが出るかを確認する

意図的に「痛みを伴う試行錯誤（Cognitive effort）」を自分に課すことで、デバッグ能力を鍛えます。

## 使用方法

```bash
# 現在のブランチの変更について壊すシナリオを提案
/learn-break

# IDEで選択中のコードについて
/learn-break --selection

# 特定ファイルについて
/learn-break --file src/components/charts/LineChart.tsx

# フォーカスエリアを指定
/learn-break error        # エラーハンドリング系
/learn-break edge         # エッジケース・境界値
/learn-break performance  # パフォーマンス・無限ループ

# 組み合わせ
/learn-break --selection error
```

## 実行フロー

### 1. 対象コードの特定

$ARGUMENTSを解析：

- `--selection` → IDEで選択中のコードを対象
- `--file <path>` → 指定ファイルを対象
- 空 / その他 → 現在のブランチの変更（main比較）を対象

フォーカス指定（`error`, `edge`, `performance`）があれば適用

### 2. 脆弱ポイントの分析

対象コードを分析し、「壊せるポイント」を特定：

- **条件分岐**: if文の条件を反転/削除したら？
- **境界値**: 配列の最初/最後、0、null、空文字
- **非同期処理**: awaitを外したら？順序を変えたら？
- **エラーハンドリング**: try-catchを外したら？
- **型**: 型を無視したら？anyを使ったら？
- **依存関係**: 引数を変えたら？undefinedを渡したら？

### 3. 壊すシナリオの提案

**提案数**: 3〜5シナリオ

各シナリオで以下を提示：
1. **変更内容**: 具体的に何をどう変えるか
2. **予想課題**: 何が起きると思うか考えてもらう
3. **実験方法**: どうやって確認するか
4. **学習ポイント**: この実験で何がわかるか

### 4. 実験サポート

ユーザーが実験を行う際のサポート：
- 予想が当たったか確認
- 予想外の挙動があれば解説
- デバッグのヒント（答えは教えない）

## 出力フォーマット

### シナリオ提案

```markdown
## 🔧 壊して学ぶシナリオ

対象: `src/components/charts/LineChart.tsx` の `TrendLineChart` 関数
フォーカス: エラーハンドリング

---

### 🧪 シナリオ1: 空配列チェックを削除

**変更内容**:
```typescript
// Before
if (!data || data.length === 0) {
  return <div>データなし</div>;
}

// After (この行を削除)
// if (!data || data.length === 0) {
//   return <div>データなし</div>;
// }
```

**実験前に予想してください**:
- 何が起きると思いますか？
- Rechartsはどう反応しますか？
- エラーは出ますか？

**確認方法**:
1. 上記の変更を加える
2. `npm run dev` で起動
3. チャートページにアクセス
4. ブラウザコンソール（F12）でエラーを確認

**学習ポイント**:
空データ処理がなぜ重要か、早期リターンの価値

---

### 🧪 シナリオ2:色の値を無理やり変える

**変更内容**:
```typescript
// Before
stroke={color}  // color = '#0ea5e9'

// After
stroke="invalidColor"  // 無効な色値
```

**実験前に予想してください**:
- グラフの色はどうなりますか？
- グラフは描画されますか？
- コンソールエラーは出ますか？

**学習ポイント**:
プロパティバリデーション、Recharts の許容性

---

### 🧪 シナリオ3: データキーを間違える

**変更内容**:
```typescript
// Before
<Line dataKey="value" />

// After
<Line dataKey="wrongKey" />
```

**実験前に予想してください**:
- グラフは描画されますか？
- データはプロットされますか？
- 見た目はどうなりますか？

**学習ポイント**:
Rechartsのデータキー マッピング、デバッグ方法

---

## 💡 実験のコツ

1. **変更前に予想を立てる**: これが最も重要！
2. **一つずつ変える**: 複数同時に変えると原因がわからなくなる
3. **元に戻せるように**: git stash や別ブランチで実験
4. **エラーメッセージを読む**: スタックトレースから原因を追う

## 🚨 注意

- 実験後は必ず元に戻してください: `git checkout -- <file>`
- 本番環境では絶対に実験しないでください
- テストコードで実験するのがベストです

---

実験する準備ができたら、予想を教えてください！
シナリオ番号と、あなたの予想を入力してください。
```

### 実験後のフィードバック

```markdown
## 📊 実験結果

### シナリオ1: 空配列チェックを削除

**あなたの予想**: Rechartsはエラーを出す
**実際の結果**: Recharts Warning: "Unsupported data structure"

✅ 予想通り！

**解説**:
- Rechartsはデータ配列が空でも動作しようとする
- しかし意図した動作（データの描画）ができない
- 早期リターンのチェックがないと、ユーザーには何も表示されない（不親切）

**さらに深掘り**:
- TypeScript の配列型チェック `data.length === 0` の重要性
- 防御的プログラミングの価値

---

### 🎯 学んだこと

1. 早期リターン（ガード節）の重要性
2. Rechartsのエラー処理方法
3. デバッグ時のコンソール確認の重要性

💡 `/learn-quiz` で理解度をテストしてみましょう
```

## フォーカスエリア別のシナリオ例

### error（エラーハンドリング）
- try-catchを外す
- エラーメッセージの表示を削除
- 非同期エラーのハンドリングを外す
- null/undefined チェックを削除

### edge（エッジケース）
- 空配列、空文字、null、undefined
- 配列の最初/最後の要素
- 0、負の数、非常に大きな数
- 非常に長い文字列

### performance（パフォーマンス）
- React.memo を削除
- キー不指定でリストレンダリング
- 不要な再計算を追加
- 無限ループの条件

## デバッグ支援モード

実験中にエラーが出て困ったら「ヒントをください」と言ってください。

**ヒントの段階**:
1. **方向性ヒント**: どの辺りを見るべきか
2. **具体的ヒント**: エラーの種類、関連する概念
3. **解決策**: 最終手段として答えを提示

> 「答え」を聞くのではなく、「原因の切り分け方」や「デバッグの戦略」を相談する

## 関連スキル

- `/learn-explain` - コードの詳細解説
- `/learn-quiz` - 理解度テスト
- `/codex-review` - コードレビュー（品質チェック）
